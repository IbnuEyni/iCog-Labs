use io;

/* Read instance data. The input files follow the "Taillard" format */
function input() {
    local usage = "Usage: hexaly jobshop.hxm inFileName=instanceFile "
            + "[outFileName=outputFile] [hxTimeLimit=timeLimit]";
    if (inFileName == nil) throw usage;

    inFile = io.openRead(inFileName);
    inFile.readln();
    nbJobs = inFile.readInt();
    nbMachines = inFile.readInt();
    inFile.readln();
    inFile.readln();
    // Processing times for each job on each machine (given in the processing order)
    processingTimesInProcessingOrder[j in 0...nbJobs][m in 0...nbMachines] = inFile.readInt();
    inFile.readln();
    for [j in 0...nbJobs][k in 0...nbMachines] {
        local m = inFile.readInt() - 1;
        // Processing order of machines for each job
        machineOrder[j][k] = m;
        // Reorder processing times: processingTime[j][m] is the processing time of the
        // task of job j that is processed on machine m
        processingTime[j][m] = processingTimesInProcessingOrder[j][k];
    }
    inFile.close();

    // Trivial upper bound for the start times of the tasks
    maxStart = sum[j in 0...nbJobs][m in 0...nbMachines] (processingTime[j][m]);
}

/* Declare the optimization model */
function model() {
    // Interval decisions: time range of each task
    // tasks[j][m] is the interval of time of the task of job j which is processed
    // on machine m
    tasks[j in 0...nbJobs][m in 0...nbMachines] <- interval(0, maxStart);

    // Task duration constraints
    for [j in 0...nbJobs][m in 0...nbMachines]
        constraint length(tasks[j][m]) == processingTime[j][m];

    // Precedence constraints between the tasks of a job
    for [j in 0...nbJobs][k in 0...nbMachines-1]
        constraint tasks[j][machineOrder[j][k]] < tasks[j][machineOrder[j][k + 1]];

    // Sequence of tasks on each machine
    jobsOrder[m in 0...nbMachines] <- list(nbJobs);

    for [m in 0...nbMachines] {
        // Each job has a task scheduled on each machine
        constraint count(jobsOrder[m]) == nbJobs;

        // Disjunctive resource constraints between the tasks on a machine
        constraint and(0...nbJobs-1,
                i => tasks[jobsOrder[m][i]][m] < tasks[jobsOrder[m][i + 1]][m]);
    }

    // Minimize the makespan: end of the last task of the last job
    makespan <- max[j in 0...nbJobs] (end(tasks[j][machineOrder[j][nbMachines - 1]]));
    minimize makespan;
}

/* Parameterize the solver */
function param() {
    if (hxTimeLimit == nil) hxTimeLimit = 60;
}

/* Write the solution in a file with the following format:
 *  - for each machine, the job sequence */
function output() {
    if (outFileName != nil) {
        outFile = io.openWrite(outFileName);
        println("Solution written in file ", outFileName);
        for [m in 0...nbMachines]
            outFile.println[j in 0...nbJobs](jobsOrder[m].value[j], " ");
    }
}
